---
title: "In the zone"
date: "2025-04-21T10:31:22.490Z"
description: "What vibe coding really means"
available: true
image: "https://substackcdn.com/image/fetch/$s_!zg61!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbc9e1edd-f629-4056-9e3f-60beb81cdb80_1536x1024.png"
link: "https://hugodemenez.substack.com/p/in-the-zone"
---

# In the zone

<Date date="2025-04-21T10:31:22.490Z" />


If you're a programmer, you've probably heard the term "vibe coding" thrown around. Or maybe you've just felt it, that odd mix of flow state and chaos where the code seems to write itself—except it's not really you writing it.

For the past two years, I've been vibe coding almost daily. But what is it really?

![](https://substackcdn.com/image/fetch/$s_!zg61!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbc9e1edd-f629-4056-9e3f-60beb81cdb80_1536x1024.png)

## **The rise of AI as your pair programmer**

At its core, vibe coding is about using AI to write code. Not just assist, but sometimes generate entire functions, modules, or even systems. You describe what you want to build, and the AI fills in the blanks. It's like having a coding buddy who doesn’t sleep, and who doesn’t always get it right—but is weirdly fast.

I’ve called it being the chef d’orchestre in a previous post. You’re no longer typing every line. You’re directing. Curating. Asking. Tweaking. Shipping.

![](https://substackcdn.com/image/fetch/$s_!OFrQ!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac2ec863-370e-47ba-b6bb-b51b8f94fed7_1536x1024.png)

## **The upside: speed like never before**

The most obvious benefit? You can move fast. Really fast.

Vibe coding cuts down boilerplate, scaffolds full apps, and takes some of the grind out of software development. If you know what you want to build and can express it clearly, the AI can give you something runnable in minutes.

This lets you prototype more. Iterate more. Even get playful with your ideas instead of treating each commit like it’s carved in stone.

![](https://substackcdn.com/image/fetch/$s_!iqvI!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff0851cde-6b08-41be-bdcf-c40e146ac1cb_1536x1024.png)

## **But it comes at a cost**

Vibe coding creates codebases that feel more like something you found than something you built. They work—until they don’t. And when they break, debugging can feel like deciphering someone else's dream.

Because you didn’t write every line, your mental model of the system might be thin. The AI doesn’t care about your architecture or naming conventions. It just wants to get the job done.

This can lead to messy, inconsistent projects. Harder onboarding. More edge-case bugs. Sometimes even stuff that feels like ghost logic—"how is this working again?"

![](https://substackcdn.com/image/fetch/$s_!JqWR!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7afd479f-5385-49d7-826c-f64540331127_1536x1024.png)

## **Where do we go from here?**

Vibe coding isn’t going away. If anything, it’s becoming the default for a whole generation of builders. But like any tool, it needs boundaries. Better tooling, smarter integrations, and clearer team practices could all help.

Maybe it’s not about saying goodbye to vibe coding—but about finding ways to vibe responsibly.

![](https://substackcdn.com/image/fetch/$s_!tAx1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fed3c85ba-864b-410b-aa1c-b1489411eecb_1536x1024.png)
